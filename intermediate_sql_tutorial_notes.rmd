---
title: "Intermediate SQL Tutorial Notes"
output: html_document
---

# Intermediate SQL Tutorial Notes

# SQL COUNT

## Write a query to count the number of non-null rows in the low column.

```{sql}
SELECT COUNT(low) AS count_low
  FROM tutorial.aapl_historical_stock_price
```

## Write a query that determines counts of every single column. Which column has the most null values?

```{sql}
SELECT COUNT(date) AS count_date,
       COUNT(year) AS count_year,
       COUNT(month) AS count_month,
       COUNT(open) AS count_open,
       COUNT(high) AS count_high,
       COUNT(low) AS count_low,
       COUNT(close) AS count_close,
       COUNT(volume) AS count_volume,
       COUNT(id) AS count_id
  FROM tutorial.aapl_historical_stock_price

-- column high has the most null values
```

# SQL SUM

## Write a query to calculate the average opening price (hint: you will need to use both COUNT and SUM, as well as some simple arithmetic.).

```{sql}
SELECT SUM(open) / COUNT(open) AS avg_open
  FROM tutorial.aapl_historical_stock_price
```

# SQL MIN/MAX

## What was Apple's lowest stock price (at the time of this data collection)?

```{sql}
SELECT MIN(low) AS min_low
  FROM tutorial.aapl_historical_stock_price
```

## What was the highest single-day increase in Apple's share value?

```{sql}
SELECT MAX(close - open) AS max_increase
  FROM tutorial.aapl_historical_stock_price
```

# SQL AVG

## Write a query that calculates the average daily trade volume for Apple stock.

```{sql}
SELECT AVG(volume) AS avg_volume
  FROM tutorial.aapl_historical_stock_price
```

# SQL GROUP BY

## Calculate the total number of shares traded each month. Order your results chronologically.

```{sql}
SELECT year,
       month,
       SUM(volume) AS num_shares
  FROM tutorial.aapl_historical_stock_price
  GROUP BY year, month
  ORDER BY year, month
```

## Write a query to calculate the average daily price change in Apple stock, grouped by year.

```{sql}
SELECT year,
       AVG(close - open) AS avg_price_change
  FROM tutorial.aapl_historical_stock_price
  GROUP BY year
  ORDER BY year

```

## Write a query that calculates the lowest and highest prices that Apple stock achieved each month.

```{sql}
SELECT year,
       month,
       MIN(low) AS lowest_monthy_price,
       MAX(high) AS highest_monthy_price
  FROM tutorial.aapl_historical_stock_price
  GROUP BY year, month
  ORDER BY year, month
```

# SQL HAVING

```{sql}
SELECT year,
       month,
       MAX(high) AS month_high
  FROM tutorial.aapl_historical_stock_price
 GROUP BY year, month
HAVING MAX(high) > 400
 ORDER BY year, month
```

If you wanted to filter the year or month, you could add the condition to the HAVING using AND, or use a WHERE clause as well:

```{sql}
SELECT year,
       month,
       MAX(high) AS month_high
  FROM tutorial.aapl_historical_stock_price
 GROUP BY year, month
HAVING MAX(high) > 400 AND month > 8
 ORDER BY year, month
```

```{sql}
SELECT year,
       month,
       MAX(high) AS month_high
  FROM tutorial.aapl_historical_stock_price
  WHERE month > 8
 GROUP BY year, month
HAVING MAX(high) > 400
 ORDER BY year, month
```

Order must be:

1. SELECT
2. FROM
3. WHERE
4. GROUP BY
5. HAVING
6. ORDER BY

# SQL CASE

## Write a query that includes a column that is flagged "yes" when a player is from California, and sort the results with those players first.

```{sql}
SELECT player_name,
       state,
       CASE WHEN state = 'CA' THEN 'yes'
       ELSE 'no' END AS is_in_california
  FROM benn.college_football_players
  ORDER BY is_in_california DESC
```

## Write a query that includes players' names and a column that classifies them into four categories based on height. Keep in mind that the answer we provide is only one of many possible answers, since you could divide players' heights in many ways.

```{sql}
SELECT player_name,
       height,
       CASE WHEN height > 78 THEN 'over 78'
            WHEN height > 73 AND height <= 78 THEN '73-78'
            WHEN height > 68 AND height <= 73 THEN '68-73'
            ELSE '68 or under' END AS height_group
  FROM benn.college_football_players
```
## Write a query that selects all columns from benn.college_football_players and adds an additional column that displays the player's name if that player is a junior or senior.

```{sql}
SELECT *,
       CASE WHEN year = 'JR' OR year = 'SR' THEN player_name
       ELSE NULL END AS is_junior_or_senior
  FROM benn.college_football_players
```

```{sql}
SELECT *,
       CASE WHEN year IN ('JR', 'SR') THEN player_name
       ELSE NULL END AS is_junior_or_senior
  FROM benn.college_football_players
```

## Write a query that counts the number of 300lb+ players for each of the following regions: West Coast (CA, OR, WA), Texas, and Other (Everywhere else).

```{sql}
SELECT CASE WHEN weight >= 300 THEN 'greater_than_300'
       ELSE '300_or_less' END AS weight_class,
       CASE WHEN state IN ('CA', 'OR', 'WA') THEN 'west_coast'
            WHEN state = 'TX' THEN 'texas'
            ELSE 'other' END AS location,
       COUNT (1) AS player_count
       FROM benn.college_football_players
       GROUP BY 1,2
```

The answer provided by the tutorial only gives those above, and not those below as well, because it uses WHERE instead of having a separate weight CASE and grouping sequentially.
```{sql}
SELECT CASE WHEN state IN ('CA', 'OR', 'WA') THEN 'West Coast'
            WHEN state = 'TX' THEN 'Texas'
            ELSE 'Other' END AS arbitrary_regional_designation,
            COUNT(1) AS players
  FROM benn.college_football_players
 WHERE weight >= 300
 GROUP BY 1
```

## Write a query that calculates the combined weight of all underclass players (FR/SO) in California as well as the combined weight of all upperclass players (JR/SR) in California.

```{sql}
SELECT CASE WHEN year IN ('FR', 'SO') THEN 'underclass'
            WHEN year IN ('JR','SR')  THEN 'upperclass'
            ELSE NULL END AS player_class,
       SUM (weight) AS combined_weight
  FROM benn.college_football_players
  WHERE state = 'CA'
  GROUP BY 1
```


## Write a query that displays the number of players in each state, with FR, SO, JR, and SR players in separate columns and another column for the total number of players. Order results such that states with the most players come first.

```{sql}
SELECT state,
       COUNT(CASE WHEN year = 'FR' THEN 1 ELSE NULL END) AS fr_count,
       COUNT(CASE WHEN year = 'SO' THEN 1 ELSE NULL END) AS so_count,
       COUNT(CASE WHEN year = 'JR' THEN 1 ELSE NULL END) AS jr_count,
       COUNT(CASE WHEN year = 'SR' THEN 1 ELSE NULL END) AS sr_count,
       COUNT(year) AS total_count
  FROM benn.college_football_players
  GROUP BY state
  ORDER BY total_count DESC
```

## Write a query that shows the number of players at schools with names that start with A through M, and the number at schools with names starting with N - Z.

```{sql}
-- note that this is wrong because <'N' is not equivalent to BETWEEN 'A' AND 'M', beacuse words like "Memphis" are not <='M', because they contain more letters after M. As this is, it will only work if hte school name is just the letter 'M'. The proper way to do this is <'N', which will capture any word starting with M.
SELECT CASE WHEN school_name BETWEEN 'A' AND 'M' THEN 'a-m'
            WHEN school_name BETWEEN 'N' AND 'Z' THEN 'n-z'
            ELSE 'no_name' END AS school_alphabet_class,
       count(school_name) AS school_alphabet_name_count
       FROM benn.college_football_players
       GROUP BY 1
        

a-m	11278
no_name	2508
n-z	12512

SELECT CASE WHEN school_name < 'N' THEN 'a-m'
            WHEN school_name >= 'N' THEN 'n-z'
            ELSE 'no_name' END AS school_alphabet_class,
       count(school_name) AS school_alphabet_name_count
       FROM benn.college_football_players
       GROUP BY 1
        

```


```{sql}
SELECT COUNT(CASE WHEN school_name < 'N' THEN 'a-m' ELSE NULL END) AS a_m_count,
       COUNT(CASE WHEN school_name >= 'N' THEN 'n-z' ELSE NULL END) AS n_z_count
       FROM benn.college_football_players
       
```

# SQL DISTINCT

## Write a query that returns the unique values in the year column, in chronological order.

```{sql}
SELECT DISTINCT year
  FROM tutorial.aapl_historical_stock_price
  ORDER BY year
```

## Write a query that counts the number of unique values in the month column for each year.

```{sql}
SELECT year,
  COUNT(DISTINCT month) AS distinct_months
  FROM tutorial.aapl_historical_stock_price
  GROUP BY year

```

## Write a query that separately counts the number of unique values in the month column and the number of unique values in the `year` column.

```{sql}
SELECT 
  COUNT(DISTINCT year) AS distinct_years,
  COUNT(DISTINCT month) AS distinct_months
  FROM tutorial.aapl_historical_stock_price

```



```{sql}

```

```{sql}

```

```{sql}

```

```{sql}

```

