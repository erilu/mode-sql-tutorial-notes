---
title: "Advanced SQL Tutorial Exercises and Notes"
output: html_document
---

# Advanced SQL Tutorial Exercises and Notes

## SQL Data Types

### Convert the funding_total_usd and founded_at_clean columns in the tutorial.crunchbase_companies_clean_date table to strings (varchar format) using a different formatting function for each one

```{sql}
SELECT CAST(founded_at_clean AS VARCHAR) AS founded_at_clean_varchar,
       funding_total_usd::VARCHAR AS funding_total_usd_varchar
FROM tutorial.crunchbase_companies_clean_date
```

## SQL Date Format

```{sql}
SELECT companies.permalink,
       companies.founded_at_clean,
       acquisitions.acquired_at_cleaned,
       acquisitions.acquired_at_cleaned -
         companies.founded_at_clean::timestamp AS time_to_acquisition
  FROM tutorial.crunchbase_companies_clean_date companies
  JOIN tutorial.crunchbase_acquisitions_clean_date acquisitions
    ON acquisitions.company_permalink = companies.permalink
 WHERE founded_at_clean IS NOT NULL
 
 -- returns the interval in number of days
 
 SELECT companies.permalink,
       companies.founded_at_clean,
       companies.founded_at_clean::timestamp +
         INTERVAL '1 week' AS plus_one_week
  FROM tutorial.crunchbase_companies_clean_date companies
 WHERE founded_at_clean IS NOT NULL
 
 -- returns the date plus exactly 1 week
 
 
```

### Write a query that counts the number of companies acquired within 3 years, 5 years, and 10 years of being founded (in 3 separate columns). Include a column for total companies acquired as well. Group by category and limit to only rows with a founding date.

```{sql}
SELECT companies.category_code,
       COUNT(*) AS total_acquisitions,
       
       -- this is the provided solution
       COUNT(CASE WHEN acquisitions.acquired_at_cleaned <= companies.founded_at_clean::timestamp + INTERVAL '3 years'
                       THEN 1 ELSE NULL END) AS acquired_3_yrs,
       COUNT(CASE WHEN acquisitions.acquired_at_cleaned <= companies.founded_at_clean::timestamp + INTERVAL '5 years'
                       THEN 1 ELSE NULL END) AS acquired_5_yrs,
       COUNT(CASE WHEN acquisitions.acquired_at_cleaned <= companies.founded_at_clean::timestamp + INTERVAL '10 years'
                       THEN 1 ELSE NULL END) AS acquired_10_yrs,
                       
      -- this is what I first came up with, but it provides different results, even though it looks like it should be the same.
       COUNT(CASE WHEN acquisitions.acquired_at_cleaned - companies.founded_at_clean::timestamp  <= INTERVAL '3 years' 
       THEN 'within_3_years' ELSE NULL END) AS acquired_within_3,
       COUNT(CASE WHEN acquisitions.acquired_at_cleaned - companies.founded_at_clean::timestamp <= INTERVAL '5 years' 
       THEN 'within_5_years' ELSE NULL END) AS acquired_within_5,
       COUNT(CASE WHEN acquisitions.acquired_at_cleaned - companies.founded_at_clean::timestamp <= INTERVAL '10 years' 
       THEN 'within_10_years' ELSE NULL END) AS acquired_within_10
  FROM tutorial.crunchbase_companies_clean_date companies
  JOIN tutorial.crunchbase_acquisitions_clean_date acquisitions
 ON companies.permalink = acquisitions.company_permalink
 WHERE companies.founded_at_clean IS NOT NULL
 GROUP BY companies.category_code
 ORDER BY 2 DESC
```

This shows that when using comparison operators on dates, always compare dates to other dates, and add the difference between dates as timestamps (rather than comparing intervals, which may produce results like the above).

## Data Wrangling in SQL

## Using SQL String Functions to Clean Data

The TRIM function is interesting, in that the order of the characters that you specify trimmed doesn't matter - it will search the leading or trailing ends (if 'both' is selected) for any of the characters and trim them off if they occur sequentially. If not specified, it will trim whitespace.


### Write a query that separates the `location` field into separate fields for latitude and longitude. You can compare your results against the actual `lat` and `lon` fields in the table.
```{sql}
-- this makes the lat and lon have the same number of digits as the actual fields in the table
SELECT location,
       lat,
       lon,
       LEFT(TRIM(both '()' FROM location), 7) AS sep_lat,
       SUBSTR(location, POSITION(',' IN location)+2, 9) AS sep_lon
  FROM tutorial.sf_crime_incidents_2014_01
  
  
-- this obtains all the significant digits provided by the location field
SELECT location,
       TRIM(leading '(' FROM LEFT(location, POSITION(',' IN location) - 1)) AS lattitude,
       TRIM(trailing ')' FROM RIGHT(location, LENGTH(location) - POSITION(',' IN location) ) ) AS longitude
  FROM tutorial.sf_crime_incidents_2014_01
```


### Concatenate the lat and lon fields to form a field that is equivalent to the location field. (Note that the answer will have a different decimal precision.)
```{sql}
SELECT location,
       lat,
       lon,
       CONCAT ('(', lat, ', ', lon, ')') AS concat_location
  FROM tutorial.sf_crime_incidents_2014_01
```

### Create the same concatenated location field, but using the || syntax instead of CONCAT.
```{sql}
SELECT location,
       lat,
       lon,
       '(' || lat || ', ' || lon || ')' AS concat_location
  FROM tutorial.sf_crime_incidents_2014_01
```

### Write a query that creates a date column formatted YYYY-MM-DD.
```{sql}
SELECT date,
       CONCAT ( SUBSTR (date, 7, 4), '-', LEFT(date,2),'-', SUBSTR(date, 4, 2) ) AS reformatted_date
  FROM tutorial.sf_crime_incidents_2014_01
```

### Write a query that returns the `category` field, but with the first letter capitalized and the rest of the letters in lower-case.
```{sql}
SELECT category,
       UPPER(LEFT (category,1)) || LOWER(RIGHT(category, LENGTH(category)-1)) AS category_resized
  FROM tutorial.sf_crime_incidents_2014_01
  
  -- another option using SUBSTR
  
SELECT category,
       UPPER(LEFT (category,1)) || LOWER(SUBSTR(category, 2, LENGTH(category)-1)) AS category_resized
  FROM tutorial.sf_crime_incidents_2014_01
```

### Write a query that creates an accurate timestamp using the date and time columns in tutorial.sf_crime_incidents_2014_01. Include a field that is exactly 1 week later as well.

```{sql}
SELECT incidnt_num,
       date,
       time,
       (SUBSTR(date, 7, 4) || '-' || LEFT(date, 2) ||
        '-' || SUBSTR(date, 4, 2) || ' ' || time || ':00')::timestamp AS cleaned_date,
       (SUBSTR(date, 7, 4) || '-' || LEFT(date, 2) ||
        '-' || SUBSTR(date, 4, 2) || ' ' || time || ':00')::timestamp + INTERVAL '1 week' AS one_week_later_date
  FROM tutorial.sf_crime_incidents_2014_01
```

Way to extract components from the cleaned date:

```{sql}
SELECT cleaned_date,
       EXTRACT('year'   FROM cleaned_date) AS year,
       EXTRACT('month'  FROM cleaned_date) AS month,
       EXTRACT('day'    FROM cleaned_date) AS day,
       EXTRACT('hour'   FROM cleaned_date) AS hour,
       EXTRACT('minute' FROM cleaned_date) AS minute,
       EXTRACT('second' FROM cleaned_date) AS second,
       EXTRACT('decade' FROM cleaned_date) AS decade,
       EXTRACT('dow'    FROM cleaned_date) AS day_of_week
  FROM tutorial.sf_crime_incidents_cleandate
```


### Write a query that counts the number of incidents reported by week. Cast the week as a date to get rid of the hours/minutes/seconds.
```{sql}
SELECT DATE_TRUNC('week', cleaned_date)::date AS week,
       COUNT(incidnt_num) as num_incidents
  FROM tutorial.sf_crime_incidents_cleandate
  GROUP BY 1
  ORDER BY 1
```

### Write a query that shows exactly how long ago each indicent was reported. Assume that the dataset is in Pacific Standard Time (UTC - 8).
```{sql}
SELECT incidnt_num,
       cleaned_date,
       NOW() AT TIME ZONE 'PST' AS time_now,
       NOW() AT TIME ZONE 'PST' - cleaned_date AS time_since_incident
  FROM tutorial.sf_crime_incidents_cleandate
```

### COALESCE to fill in NULL values

```{sql}
--useful way to fill in null values for a column with a specified replacement value

SELECT incidnt_num,
       descript,
       COALESCE(descript, 'No Description')
  FROM tutorial.sf_crime_incidents_cleandate
 ORDER BY descript DESC
```


## Writing Subqueries in SQL

### Write a query that selects all Warrant Arrests from the tutorial.sf_crime_incidents_2014_01 dataset, then wrap it in an outer query that only displays unresolved incidents.

```{sql}
SELECT sub.*
  FROM (
        SELECT *
          FROM tutorial.sf_crime_incidents_2014_01
         WHERE descript = 'WARRANT ARREST'
       ) sub
 WHERE sub.resolution = 'NONE'
```

### Write a query that displays the average number of monthly incidents for each category. Hint: use tutorial.sf_crime_incidents_cleandate to make your life a little easier.

```{sql}
SELECT 
       sub.category,
       AVG(sub.incidents) AS average_incidents
  FROM (
        SELECT 
               DATE_TRUNC('month'  , cleaned_date) AS month,
               category,
               COUNT(incidnt_num) AS incidents
          FROM tutorial.sf_crime_incidents_cleandate
         GROUP BY 1,2
       ) sub
 GROUP BY 1
 ORDER BY 1
```


```{sql}
SELECT sub.month,
       AVG(sub.volume_sum) AS avg_volume_per_month
FROM
(SELECT year,
       month,
       SUM(volume) AS volume_sum
  FROM tutorial.aapl_historical_stock_price
 GROUP BY year, month
 ORDER BY year, month) sub
 GROUP BY 1
 ORDER BY 1

```

### Write a query that displays all rows from the three categories with the fewest incidents reported.

```{sql}
SELECT incidents.*,
       sub.incidents AS incidents_in_category
  FROM tutorial.sf_crime_incidents_2014_01 incidents
  JOIN ( SELECT category,
          COUNT(incidnt_num) AS incidents
           FROM tutorial.sf_crime_incidents_2014_01
          GROUP BY 1
          ORDER BY 2
          LIMIT 3
       ) sub
    ON incidents.category = sub.category
 ORDER BY sub.incidents
```

### BONUS Exercise

I applied the subquery method to revisit one of the previous exercises, which used a self-join, since the methods seemed fairly similar in their utility. This code also lists the companies which had GBR investors after an initial investment in japan.

```{sql}

 SELECT DISTINCT japan_investments.company_name,
       japan_investments.company_permalink
  FROM tutorial.crunchbase_investments_part1 japan_investments
  JOIN ( SELECT gb_investments.investor_country_code,
                gb_investments.company_name,
                gb_investments.funded_at
          FROM tutorial.crunchbase_investments_part1 gb_investments
          WHERE gb_investments.investor_country_code = 'GBR') sub
   ON japan_investments.company_name = sub.company_name     
  AND sub.funded_at > japan_investments.funded_at
  WHERE japan_investments.investor_country_code = 'JPN'
  ORDER BY 1

```

### Write a query that counts the number of companies founded and acquired by quarter starting in Q1 2012. Create the aggregations in two separate queries, then join them.

```{sql}
SELECT COALESCE(companies.quarter, acquisitions.quarter) AS quarter,
       companies.companies_founded,
       acquisitions.companies_acquired

  FROM (
        SELECT founded_quarter AS quarter,
               COUNT(DISTINCT permalink) AS companies_founded
          FROM tutorial.crunchbase_companies
         WHERE founded_year >= 2012
         GROUP BY 1
         
       ) companies

  LEFT JOIN (
        SELECT acquired_quarter AS quarter,
               COUNT(DISTINCT company_permalink) AS companies_acquired
          FROM tutorial.crunchbase_acquisitions
         WHERE acquired_year >= 2012
         GROUP BY 1
       ) acquisitions
    ON acquisitions.quarter = companies.quarter
 ORDER BY 1
```


### Write a query that ranks investors from the combined dataset above by the total number of investments they have made.
```{sql}
SELECT investor_name,
COUNT(*) AS total_investments
  FROM (
        SELECT *
          FROM tutorial.crunchbase_investments_part1

         UNION ALL

        SELECT *
          FROM tutorial.crunchbase_investments_part2
       ) sub
  GROUP BY investor_name
  ORDER BY 2 DESC
```


### Write a query that does the same thing as in the previous problem, except only for companies that are still operating. Hint: operating status is in tutorial.crunchbase_companies.
```{sql}
SELECT investments.investor_name,
COUNT(investments.*) AS total_investments
  FROM (
        SELECT *
          FROM tutorial.crunchbase_investments_part1

         UNION ALL

        SELECT *
          FROM tutorial.crunchbase_investments_part2
       ) investments
  JOIN (
        SELECT permalink,
               status
        FROM tutorial.crunchbase_companies
        WHERE status = 'operating'
  ) companies
  ON investments.company_permalink = companies.permalink
  GROUP BY 1
  ORDER BY 2 DESC
  
--the query below is the answer provided by the tutorial. the difference is that the WHERE clause is applied to the table after the join, whereas I applied the WHERE to filter for operating companies before joining. both give the same result

SELECT investments.investor_name,
       COUNT(investments.*) AS investments
  FROM tutorial.crunchbase_companies companies
  JOIN (
        SELECT *
          FROM tutorial.crunchbase_investments_part1
         
         UNION ALL
        
         SELECT *
           FROM tutorial.crunchbase_investments_part2
       ) investments
    ON investments.company_permalink = companies.permalink
 WHERE companies.status = 'operating'
 GROUP BY 1
 ORDER BY 2 DESC
```


## SQL Window Functions

Self practice - if i wanted to filter the results by when the rolling sum is greater than 1000, can do a subquery of the results from the window function query.

```{sql}


SELECT *
FROM (
SELECT start_time,
       start_terminal,
       duration_seconds,
       SUM(duration_seconds) OVER
         (PARTITION BY start_terminal ORDER BY start_time) AS start_terminal_total
  FROM tutorial.dc_bikeshare_q1_2012
 WHERE start_time < '2012-01-08'
 ) sub
 WHERE sub.start_terminal_total > 1000
```

### Write a query modification of the above example query that shows the duration of each ride as a percentage of the total time accrued by riders from each start_terminal

```{sql}

SELECT sub.start_time,
       sub.start_terminal,
       sub.duration_seconds / sub.start_terminal_total *100 AS percent_time
  FROM (
        SELECT start_time,
               start_terminal,
               duration_seconds,
               SUM(duration_seconds) OVER
                 (PARTITION BY start_terminal) AS start_terminal_total
          FROM tutorial.dc_bikeshare_q1_2012
         WHERE start_time < '2012-01-08'
       ) sub
  ORDER BY 2,3 DESC

-- giving the same result wihtout a subquery
SELECT start_time,
       start_terminal,
       duration_seconds,
       SUM(duration_seconds) OVER
         (PARTITION BY start_terminal) AS start_terminal_total,
       duration_seconds / SUM(duration_seconds) OVER (PARTITION BY start_terminal) *100 AS percent_time
  FROM tutorial.dc_bikeshare_q1_2012
 WHERE start_time < '2012-01-08'
 ORDER BY 2,5 DESC

-- double check that it worked by seeing if all the percents grouped by terminal sum up to 100:
SELECT sub2.start_terminal,
       SUM (sub2.percent_time)
  FROM (
        SELECT sub.start_time,
               sub.start_terminal,
               sub.duration_seconds / sub.start_terminal_total *100 AS percent_time
          FROM (
                SELECT start_time,
                       start_terminal,
                       duration_seconds,
                       SUM(duration_seconds) OVER
                         (PARTITION BY start_terminal) AS start_terminal_total
                  FROM tutorial.dc_bikeshare_q1_2012
                 WHERE start_time < '2012-01-08'
               ) sub
         
         ) sub2
 GROUP BY 1
```

### Write a query that shows a running total of the duration of bike rides (similar to the last example), but grouped by end_terminal, and with ride duration sorted in descending order.

```{sql}
SELECT end_terminal,
       duration_seconds,
       SUM(duration_seconds) OVER
         (PARTITION BY end_terminal ORDER BY duration_seconds DESC)
         AS running_total
  FROM tutorial.dc_bikeshare_q1_2012
 WHERE start_time < '2012-01-08'
```

### Write a query that shows the 5 longest rides from each starting terminal, ordered by terminal, and longest to shortest rides within each terminal. Limit to rides that occurred before Jan. 8, 2012.

```{sql}
SELECT *
  FROM (
      SELECT start_terminal,
             start_time,
             duration_seconds,
             RANK() OVER (PARTITION BY start_terminal ORDER BY duration_seconds DESC)
                          AS row_rank
        FROM tutorial.dc_bikeshare_q1_2012
       WHERE start_time < '2012-01-08'
   ) sub
 WHERE sub.row_rank <=5
```


### Write a query that shows only the duration of the trip and the percentile into which that duration falls (across the entire dataset—not partitioned by terminal).

```{sql}
SELECT duration_seconds,
       NTILE(100) OVER
         (ORDER BY duration_seconds)
         AS percentile
  FROM tutorial.dc_bikeshare_q1_2012
 WHERE start_time < '2012-01-08'
 ORDER BY 1
```

Window functions

https://www.postgresql.org/docs/8.4/functions-window.html

Function	Return Type	Description
* row_number()	bigint	number of the current row within its partition, counting from 1
* rank()	bigint	rank of the current row with gaps; same as row_number of its first peer
* dense_rank()	bigint	rank of the current row without gaps; this function counts peer groups
* percent_rank()	double precision	relative rank of the current row: (rank - 1) / (total rows - 1)
* cume_dist()	double precision	relative rank of the current row: (number of rows preceding or peer with current row) / (total rows)
* ntile(num_buckets integer)	integer	integer ranging from 1 to the argument value, dividing the partition as equally as possible
* lag(value any [, offset integer [, default any ]])	same type as value	returns value evaluated at the row that is offset rows before the current row within the partition; if there is no such row, instead return default. Both offset and default are evaluated with respect to the current row. If omitted, offset defaults to 1 and default to null
* lead(value any [, offset integer [, default any ]])	same type as value	returns value evaluated at the row that is offset rows after the current row within the partition; if there is no such row, instead return default. Both offset and default are evaluated with respect to the current row. If omitted, offset defaults to 1 and default to null
* first_value(value any)	same type as value	returns value evaluated at the row that is the first row of the window frame
* last_value(value any)	same type as value	returns value evaluated at the row that is the last row of the window frame
* nth_value(value any, nth integer)	same type as value	returns value evaluated at the row that is the nth row of the window frame (counting from 1); null if no such row

## Performance Tuning SQL Queries

```{sql}
-- slow query since it has to join all rows before aggregation

SELECT teams.conference AS conference,
       players.school_name,
       COUNT(1) AS players
  FROM benn.college_football_players players
  JOIN benn.college_football_teams teams
    ON teams.school_name = players.school_name
 GROUP BY 1,2
 
 
 -- faster query because it joins less rows (aggregate first, then join)

SELECT teams.conference,
       sub.*
  FROM (
        SELECT players.school_name,
               COUNT(*) AS players
          FROM benn.college_football_players players
         GROUP BY 1
       ) sub
  JOIN benn.college_football_teams teams
  ON teams.school_name = sub.school_name
```

## Pivoting Data in SQL

This chapter shows how to pivot data in SQL, very similar to using the reshape package in R (changing long format to wide format data, and vice versa. "melting" and "casting" columns).

```{sql}
-- data in long format

SELECT teams.conference AS conference,
       players.year,
       COUNT(1) AS players
  FROM benn.college_football_players players
  JOIN benn.college_football_teams teams
    ON teams.school_name = players.school_name
 GROUP BY 1,2
 ORDER BY 1,2


-- to make new columns based on players.year, this would be the SQL query required.

SELECT conference,
       SUM(players) AS total_players,
       SUM(CASE WHEN year = 'FR' THEN players ELSE NULL END) AS fr,
       SUM(CASE WHEN year = 'SO' THEN players ELSE NULL END) AS so,
       SUM(CASE WHEN year = 'JR' THEN players ELSE NULL END) AS jr,
       SUM(CASE WHEN year = 'SR' THEN players ELSE NULL END) AS sr
  FROM (
        SELECT teams.conference AS conference,
               players.year,
               COUNT(1) AS players
          FROM benn.college_football_players players
          JOIN benn.college_football_teams teams
            ON teams.school_name = players.school_name
         GROUP BY 1,2
       ) sub
 GROUP BY 1
 ORDER BY 2 DESC
```

